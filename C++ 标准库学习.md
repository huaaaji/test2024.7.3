# C++ 标准库学习

[整理主要来源：OIwiki](https://oi-wiki.org/lang/csl/)

[TOC]

## 标准库简介

### C++标准

>C++ 自 1985 年诞生以来，一共由国际标准化组织（ISO）发布了 5 个正式的 C++ 标准，依次为 C++98、C++03、C++11（亦称 C++0x）、C++14（亦称 C++1y）、C++17（亦称 C++1z）、C++20（亦称 C++2a）。C++ 标准草案在 open-std 网站上，最新的标准 C++23（亦称 C++2b）仍在制定中。此外还有一些补充标准，例如 C++ TR1。

>每一个版本的 C++ 标准不仅规定了 C++ 的*语法、语言特性*，还**规定了一套 C++ 内置库的实现规范**，这个库便是 **C++ 标准库**。C++ 标准库中包含大量常用代码的实现，如输入输出、基本数据结构、内存管理、多线程支持等。掌握 C++ 标准库是编写更现代的 C++ 代码必要的一步。C++ 标准库的详细文档在 [cppreference](https://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5) 网站上，文档对标准库中的类型函数的用法、效率、注意事项等都有介绍，请善用。

### 标准模板库（STL）

**标准模板库（Standard Template Library）**，是 C++ 标准库的一部分，里面包含了一些模板化的通用的数据结构和算法
由于其模板化的特点，它能够兼容自定义的数据类型，避免大量的造轮子（Reinventing_the_wheel）工作

STL的六大件包括容器、算法、迭代器、仿函数、适配器和空间配置器，其中几乎所有代码均使用了模板类和模板函数的概念[^1]

### Boost库

乃除了标准库外，另一个久副盛名的**开源 C++ 工具库**，其代码具有可移植、高质量、高性能、高可靠性等特点。
其模块数量非常之大，功能全面，并且拥有完备的跨平台支持，因此被看作 C++ 的准标准库。
C++ 标准中的不少特性也都来自于 Boost，如智能指针、元编程、日期和时间等

## STL容器

### STL简介

#### 分类

[分类](./pictures/container1.png)

#### 序列式容器

- **向量(vector)** 后端可高效增加元素的顺序表。
- **数组(array)** C++11，定长的顺序表，C 风格数组的简单包装。
- **双端队列(deque)** 双端都可高效增加元素的顺序表。
- **列表(list)** 可以沿双向遍历的链表。
- **单向列表(forward_list)** 只能沿一个方向遍历的链表。

#### 关联式容器

- **集合(set)** 用以有序地存储 **互异** 元素的容器。其实现是由节点组成的红黑树，每个节点都包含着一个元素，节点之间以某种比较元素大小的谓词进行排列。
- **多重集合(multiset)** 用以有序地存储元素的容器。允许存在相等的元素。
- **映射(map)** 由 `{键，值}` 对组成的集合，以某种比较键大小关系的谓词进行排列。
- **多重映射(multimap)** 由 `{键，值}` 对组成的多重集合，亦即允许键有相等情况的映射。

#### 无序（关联式）容器

- **无序（多重）集合(unordered_set/unordered_multiset)** C++11，与 `set`/`multiset` 的区别在于元素无序，只关心「元素是否存在」，使用哈希实现。
- **无序（多重）映射(unordered_map/unordered_multimap)** C++11，与 `map`/`multimap` 的区别在于键 (key) 无序，只关心 "键与值的对应关系"，使用哈希实现。

#### 容器适配器

容器适配器其实**并不是容器**。它们不具有容器的某些特点（如：有迭代器、有 clear() 函数……）
>「适配器是使一种事物的行为类似于另外一种事物行为的一种机制」，适配器对容器进行包装，使其表现出另外一种行为。

- **栈(stack)** 后进先出 (LIFO) 的容器，默认是对双端队列（deque）的包装。
- **队列(queue)** 先进先出 (FIFO) 的容器，默认是对双端队列（deque）的包装。
- **优先队列(priority_queue)** 元素的次序是**由作用于所存储的值对上的某种谓词决定的**的一种队列，默认是对向量（vector）的包装。

### 共同点

都是 `containerName<typeName,...> name` 的形式，但模板参数（`<>` 内的参数）的个数、形式会根据具体容器而变。

本质原因：STL 就是「标准模板库」，所以容器都是模板类。

**泛型编程是一种编程范式，旨在编写可以适用于多种数据类型的通用代码。**通过泛型编程，我们可以编写一次代码，然后将其应用于不同的数据类型，从而避免重复编写相似的代码
编写与类型无关的通用代码，是代码复用的一种手段。**模板是泛型编程的基础**。
面向对象编程（OOP）和泛型编程都能处理在编写程序时不知类型的情况，不同之处在于：OOP能处理类型在程序运行之前都未知的情况：而在泛型编程中，在编译时就能获知类型了

### 迭代器

### 共有函数

- =：有赋值运算符以及复制构造函数。
- begin()：返回指向开头元素的迭代器。
- end()：返回指向末尾的下一个元素的迭代器。end() 不指向某个元素，但它是末尾元素的后继。
- size()：返回容器内的元素个数。
- max_size()：返回容器 理论上 能存储的最大元素个数。依容器类型和所存储变量的类型而变。
- empty()：返回容器是否为空。
- swap()：交换两个容器。
- clear()：清空容器。
- ==/!=/</>/<=/>=：按 字典序 比较两个容器的大小。（比较元素大小时 map 的每个元素相当于 set<pair<key, value> >，无序容器不支持 </>/<=/>=。）

***

注：
[^1]: [链接](https://blog.csdn.net/baidu_35536188/article/details/122881541)
[^2]: 